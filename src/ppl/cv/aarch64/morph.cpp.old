// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

#include "ppl/cv/aarch64/arithmetic.h"
#include "ppl/cv/aarch64/morph.hpp"

#include <assert.h>
#include <stdio.h>
#include <cmath>
#include <float.h>
#include "string.h"
#include "typetraits.hpp"
#include <arm_neon.h>
#include "ppl/common/log.h"
#include "common.hpp"
#include <iostream>

namespace ppl {
namespace cv {
namespace aarch64 {

#define p(x) LOG(INFO) << " "#x;vprint<nc, v_dt>(x);


template<int nc, typename T>
void vprint(T t){
    float32_t data[4*nc] = {};
    stq(data, t);
    for(int i = 0; i < nc; i++){
        for(int j = 0; j < 4; j++){
            std::cout << data[i*4 + j] << " ";
        }
    }
    std::cout << std::endl;
}

template<>
void vprint<1, uint8x16_t>(uint8x16_t t){
    uint8_t data[16*1] = {};
    stq(data, t);
    for(int i = 0; i < 1; i++){
        for(int j = 0; j < 16; j++){
            std::cout << static_cast<int32_t>(data[i*16 + j]) << " ";
        }
    }
    std::cout << std::endl;
}

template<>
void vprint<3, uint8x16x3_t>(uint8x16x3_t t){
    uint8_t data[16*3] = {};
    stq(data, t);
    for(int i = 0; i < 3; i++){
        for(int j = 0; j < 16; j++){
            std::cout << static_cast<int32_t>(data[i*16 + j]) << " ";
        }
    }
    std::cout << std::endl;
}
template<>
void vprint<4, uint8x16x4_t>(uint8x16x4_t t){
    uint8_t data[16*4] = {};
    stq(data, t);
    for(int i = 0; i < 4; i++){
        for(int j = 0; j < 16; j++){
            std::cout << static_cast<int32_t>(data[i*16 + j]) << " ";
        }
    }
    std::cout << std::endl;
}

#define VLEN 16 // 16 bytes = 128 bits for  reg
template <typename T>
inline T *getRowPtr(T *base, int32_t stride, int32_t row)
{
    T *baseRaw = const_cast<T *>(reinterpret_cast<const T *>(base));
    return reinterpret_cast<T *>(baseRaw + row * stride);
}

template <class morphOp, typename T, int32_t nc, int32_t kernel_len>
inline void MorphRow(typename DT<nc, T>::vec_DT &tprev, typename DT<nc, T>::vec_DT &tcurr, typename DT<nc, T>::vec_DT &tnext, const T *srcCenterRow, int32_t srcStride, T *drow, int32_t rowIdx, int32_t rowIdxInv, int32_t colIdx, int32_t colIdxInv, T borderValue = 0)
{
    using v_dt = typename DT<nc, T>::vec_DT;
    auto vext = vextq<nc, v_dt>;
    v_dt v_border;
    vdupq<nc, v_dt>(v_border, borderValue);
    switch (kernel_len) {
        case 3: {
            v_dt v_up, v_mid, v_down;
            v_dt t_left, t_mid, t_right;
            v_up = rowIdx == 0 ? v_border : vldnq(v_up, srcCenterRow - srcStride);
            v_mid = vldnq(v_mid, srcCenterRow);
            v_down = rowIdxInv == 0 ? v_border: vldnq(v_down, srcCenterRow + srcStride);

            compare<morphOp, nc, v_dt>(tnext, v_up, v_mid, v_down);

            vext(t_left, tprev, tcurr, VLEN/sizeof(T) - 1); 
            t_mid = tcurr;
            vext(t_right, tcurr, tnext, 1);
            compare<morphOp, nc, v_dt>(t_mid, t_left, t_mid, t_right);
            stq(drow, t_mid);
        } break;
        case 5: {
            v_dt v_up0, v_up1, v_mid, v_down0, v_down1;
            v_up0   = vldnq(v_up0, srcCenterRow - 2 * srcStride);
            v_up1   = vldnq(v_up1, srcCenterRow - 1 * srcStride);
            v_mid   = vldnq(v_mid, srcCenterRow);
            v_down0 = vldnq(v_down0, srcCenterRow + 1 * srcStride);
            v_down1 = vldnq(v_down1, srcCenterRow + 2 * srcStride);

            if(rowIdx < 2) {v_up0 = v_border;} 
            if(rowIdx < 1) {v_up1 = v_border;}
            if(rowIdxInv < 1) {v_down0 = v_border;}
            if(rowIdxInv < 2) {v_down1 = v_border;}
            tnext = v_mid;
            compare<morphOp, nc, v_dt>(tnext, v_up0, v_up1, v_mid, v_down0, v_down1);
            v_dt t_left0, t_left1, t_mid, t_right0, t_right1;
            vext(t_left0, tprev, tcurr, VLEN/sizeof(T) - 2); 
            vext(t_left1, tprev, tcurr, VLEN/sizeof(T) - 1); 
            t_mid = tcurr;
            vext(t_right0, tcurr, tnext, 1); 
            vext(t_right1, tcurr, tnext, 2);
            compare<morphOp, nc, v_dt>(t_mid, t_left0, t_left1, t_mid, t_right0, t_right1);
            stq(drow, t_mid);
        } break;
        default:
            break;
    }
}

template <class morphOp, typename T, int32_t nc, int32_t kernel_len>
inline void MorphRowLast(typename DT<nc, T>::vec_DT &tprev, typename DT<nc, T>::vec_DT &tcurr, typename DT<nc, T>::vec_DT &tnext, const T *srcCenterRow, int32_t srcStride, T *drow, int32_t rowIdx, int32_t rowIdxInv, int32_t colIdx, int32_t colIdxInv, float borderValue = 0)
{
    using v_dt = typename DT<nc, T>::vec_DT;
    v_dt v_border;
    vdupq<nc, v_dt>(v_border, borderValue);
    constexpr int32_t v_elem          = VLEN / sizeof(T);
    int32_t bias = colIdxInv + 1;
    switch (kernel_len) {
        case 3: {
            v_dt t_left, t_mid, t_right;
            switch (bias) {
                case 3: {biasMov<T, nc, 3>(tprev, tcurr, tnext, t_left, t_mid, t_right, v_border);
                } break;
                case 2: {biasMov<T, nc, 2>(tprev, tcurr, tnext, t_left, t_mid, t_right, v_border);
                } break;
                case 1: {biasMov<T, nc, 1>(tprev, tcurr, tnext, t_left, t_mid, t_right, v_border);
                } break;
                case 0: {biasMov<T, nc, 0>(tprev, tcurr, tnext, t_left, t_mid, t_right, v_border);
                } break;
                default:
                    break;
            }
            compare<morphOp, nc, v_dt>(t_mid, t_left, t_mid, t_right);
            stq(drow - (v_elem - bias) * nc, t_mid);
        } break;
        case 5: {
            v_dt t_left0, t_left1, t_mid, t_right0, t_right1; 

            switch (bias) {               
                case 3: {biasMov<T, nc, 3>(tprev, tcurr, tnext, t_left0, t_left1, t_mid, t_right0, t_right1, v_border);
                } break;
                case 2: {biasMov<T, nc, 2>(tprev, tcurr, tnext, t_left0, t_left1, t_mid, t_right0, t_right1, v_border);
                } break;
                case 1: {biasMov<T, nc, 1>(tprev, tcurr, tnext, t_left0, t_left1, t_mid, t_right0, t_right1, v_border);
                } break;
                case 0: {biasMov<T, nc, 0>(tprev, tcurr, tnext, t_left0, t_left1, t_mid, t_right0, t_right1, v_border);
                } break;
                default:
                    break;
            }
            compare<morphOp, nc, v_dt>(t_mid, t_left0, t_left1, t_mid, t_right0, t_right1);
            stq(drow - (v_elem - bias) * nc, t_mid);
        } break;
        default:
            break;
    }
}

template <class morphOp, typename T, int32_t nc, int32_t kernel_len>
inline void MorphRowLast(typename DT<nc, T>::vec_DT &tprev, typename DT<nc, T>::vec_DT &tcurr, typename DT<nc, T>::vec_DT &tnext, const T *srcCenterRow, int32_t srcStride, T *drow, int32_t rowIdx, int32_t rowIdxInv, int32_t colIdx, int32_t colIdxInv, uchar borderValue = 0)
{
    using v_dt = typename DT<nc, T>::vec_DT;
    v_dt v_border;
    vdupq<nc, v_dt>(v_border, borderValue);
    constexpr int32_t v_elem          = VLEN / sizeof(T);
    int32_t bias = colIdxInv + 1;
    switch (kernel_len) {
        case 3: {
            v_dt t_left, t_mid, t_right;
            switch (bias) {
                case 15: {biasMov<T, nc, 15>(tprev, tcurr, tnext, t_left, t_mid, t_right, v_border);
                } break;
                case 14: {biasMov<T, nc, 14>(tprev, tcurr, tnext, t_left, t_mid, t_right, v_border);
                } break;
                case 13: {biasMov<T, nc, 13>(tprev, tcurr, tnext, t_left, t_mid, t_right, v_border);
                } break;
                case 12: {biasMov<T, nc, 12>(tprev, tcurr, tnext, t_left, t_mid, t_right, v_border);
                } break;
                case 11: {biasMov<T, nc, 11>(tprev, tcurr, tnext, t_left, t_mid, t_right, v_border);
                } break;
                case 10: {biasMov<T, nc, 10>(tprev, tcurr, tnext, t_left, t_mid, t_right, v_border);
                } break;
                case 9: {biasMov<T, nc, 9>(tprev, tcurr, tnext, t_left, t_mid, t_right, v_border);
                } break;
                case 8: {biasMov<T, nc, 8>(tprev, tcurr, tnext, t_left, t_mid, t_right, v_border);
                } break;
                case 7: {biasMov<T, nc, 7>(tprev, tcurr, tnext, t_left, t_mid, t_right, v_border);
                } break;
                case 6: {biasMov<T, nc, 6>(tprev, tcurr, tnext, t_left, t_mid, t_right, v_border);
                } break;
                case 5: {biasMov<T, nc, 5>(tprev, tcurr, tnext, t_left, t_mid, t_right, v_border);
                } break;
                case 4: {biasMov<T, nc, 4>(tprev, tcurr, tnext, t_left, t_mid, t_right, v_border);
                } break;
                case 3: {biasMov<T, nc, 3>(tprev, tcurr, tnext, t_left, t_mid, t_right, v_border);
                } break;
                case 2: {biasMov<T, nc, 2>(tprev, tcurr, tnext, t_left, t_mid, t_right, v_border);
                } break;
                case 1: {biasMov<T, nc, 1>(tprev, tcurr, tnext, t_left, t_mid, t_right, v_border);
                } break;
                case 0: {biasMov<T, nc, 0>(tprev, tcurr, tnext, t_left, t_mid, t_right, v_border);
                } break;
                default:
                    break;
            }
            compare<morphOp, nc, v_dt>(t_mid, t_left, t_mid, t_right);
            stq(drow - (v_elem - bias) * nc, t_mid);
        } break;
        case 5: {
            v_dt t_left0, t_left1, t_mid, t_right0, t_right1;
            switch (bias) {
                case 15: {biasMov<T, nc, 15>(tprev, tcurr, tnext, t_left0, t_left1, t_mid, t_right0, t_right1, v_border);
                } break;
                case 14: {biasMov<T, nc, 14>(tprev, tcurr, tnext, t_left0, t_left1, t_mid, t_right0, t_right1, v_border);
                } break;
                case 13: {biasMov<T, nc, 13>(tprev, tcurr, tnext, t_left0, t_left1, t_mid, t_right0, t_right1, v_border);
                } break;
                case 12: {biasMov<T, nc, 12>(tprev, tcurr, tnext, t_left0, t_left1, t_mid, t_right0, t_right1, v_border);
                } break;
                case 11: {biasMov<T, nc, 11>(tprev, tcurr, tnext, t_left0, t_left1, t_mid, t_right0, t_right1, v_border);
                } break;
                case 10: {biasMov<T, nc, 10>(tprev, tcurr, tnext, t_left0, t_left1, t_mid, t_right0, t_right1, v_border);
                } break;
                case 9: {biasMov<T, nc, 9>(tprev, tcurr, tnext, t_left0, t_left1, t_mid, t_right0, t_right1, v_border);
                } break;
                case 8: {biasMov<T, nc, 8>(tprev, tcurr, tnext, t_left0, t_left1, t_mid, t_right0, t_right1, v_border);
                } break;
                case 7: {biasMov<T, nc, 7>(tprev, tcurr, tnext, t_left0, t_left1, t_mid, t_right0, t_right1, v_border);
                } break;
                case 6: {biasMov<T, nc, 6>(tprev, tcurr, tnext, t_left0, t_left1, t_mid, t_right0, t_right1, v_border);
                } break;
                case 5: {biasMov<T, nc, 5>(tprev, tcurr, tnext, t_left0, t_left1, t_mid, t_right0, t_right1, v_border);
                } break;
                case 4: {biasMov<T, nc, 4>(tprev, tcurr, tnext, t_left0, t_left1, t_mid, t_right0, t_right1, v_border);
                } break;
                case 3: {biasMov<T, nc, 3>(tprev, tcurr, tnext, t_left0, t_left1, t_mid, t_right0, t_right1, v_border);
                } break;
                case 2: {biasMov<T, nc, 2>(tprev, tcurr, tnext, t_left0, t_left1, t_mid, t_right0, t_right1, v_border);
                } break;
                case 1: {biasMov<T, nc, 1>(tprev, tcurr, tnext, t_left0, t_left1, t_mid, t_right0, t_right1, v_border);
                } break;
                case 0: {biasMov<T, nc, 0>(tprev, tcurr, tnext, t_left0, t_left1, t_mid, t_right0, t_right1, v_border);
                } break;
                default:
                    break;
            }
            compare<morphOp, nc, v_dt>(t_mid, t_left0, t_left1, t_mid, t_right0, t_right1);
            stq(drow - (v_elem - bias) * nc, t_mid);
        } break;
        default:
            break;
    }
}

template <class morphOp, typename T, int32_t nc, int32_t kernel_len>
inline void MorphFirstCol(typename DT<nc, T>::vec_DT &tcurr, typename DT<nc, T>::vec_DT &tnext, const T *srcCenterRow, int32_t srcStride, int32_t rowIdx, int32_t rowIdxInv, T borderValue = 0)
{
    using v_dt = typename DT<nc, T>::vec_DT;
    v_dt v_border;
    vdupq<nc, v_dt>(v_border, borderValue);
    switch (kernel_len) {
        case 3: {
            v_dt v_up, v_mid, v_down;
            v_up = rowIdx == 0 ? v_border : vldnq(v_up, srcCenterRow - srcStride);
            v_mid = vldnq(v_mid, srcCenterRow);
            v_down = rowIdxInv == 0 ? v_border: vldnq(v_down, srcCenterRow + srcStride);
            compare<morphOp, nc, v_dt>(tnext, v_up, v_mid, v_down);
            tcurr    = v_border;

        } break;
        case 5: {
            v_dt v_up0, v_up1, v_mid, v_down0, v_down1;

            v_up0 = rowIdx < 2 ? v_border : vldnq(v_up0, srcCenterRow - 2 * srcStride);
            v_up1 = rowIdx < 1 ? v_border : vldnq(v_up1, srcCenterRow - 1 * srcStride);
            v_mid = vldnq(v_mid, srcCenterRow);
            v_down0 = rowIdxInv < 1 ? v_border: vldnq(v_down0, srcCenterRow + 1 * srcStride);
            v_down1 = rowIdxInv < 2 ? v_border: vldnq(v_down1, srcCenterRow + 2 * srcStride);
            compare<morphOp, nc, v_dt>(tnext, v_up0, v_up1, v_mid, v_down0, v_down1);
            tcurr = v_border;
        } break;
        default:
            break;
    }
}

template <class morphOp, typename T, int32_t nc, int32_t kernel_len>
void morph_f32(
    const int32_t height,
    const int32_t width,
    int32_t srcStride,
    const T *srcBase,
    int32_t dstStride,
    T *dstBase,
    BorderType border_type,
    T borderValue)
{
    constexpr int32_t v_elem         = VLEN / sizeof(T);
    using v_dt = typename DT<nc, T>::vec_DT;
    v_dt tcurr, tprev, tnext, v_border;
    vdupq<nc, v_dt>(v_border, borderValue);

    for(int y = 0; y < height; y++){
        const T *srow = getRowPtr(srcBase, srcStride, y);
        T *drow       = getRowPtr(dstBase, dstStride, y);
        MorphFirstCol<morphOp, T, nc, kernel_len>(tcurr, tnext, srow, srcStride, y, height - 1 - y, borderValue);
        int32_t x = v_elem; 
        for(int i = 0; i < nc; i++){
            prefetch(srow + (i + 1) * srcStride);
            prefetch(srow - (i + 1) * srcStride);
        }
        prefetch(srow);
        prefetch(drow);
        for (; x <= width ; x += v_elem) {
       
            tprev = tcurr;
            tcurr = tnext;
            MorphRow<morphOp, T, nc, kernel_len>(tprev, tcurr, tnext, srow + x * nc, srcStride, drow, y, height - 1 - y, x - v_elem, width - 1 - (x - v_elem), borderValue); 
            drow += v_elem * nc;
        }
        MorphRowLast<morphOp, T, nc, kernel_len>(tprev, tcurr, tnext, srow + x * nc, srcStride, drow, y, height - 1 - y, x - v_elem, width - 1 - (x - v_elem), borderValue);
    }
}

template void morph_f32<DilateVecOp, float, 1, 3>(
    const int32_t height,
    const int32_t width,
    int32_t srcStride,
    const float *srcBase,
    int32_t dstStride,
    float *dstBase,
    BorderType border_type,
    float borderValue);
template void morph_f32<DilateVecOp, float, 1, 5>(
    const int32_t height,
    const int32_t width,
    int32_t srcStride,
    const float *srcBase,
    int32_t dstStride,
    float *dstBase,
    BorderType border_type,
    float borderValue);
template void morph_f32<DilateVecOp, float, 3, 3>(
    const int32_t height,
    const int32_t width,
    int32_t srcStride,
    const float *srcBase,
    int32_t dstStride,
    float *dstBase,
    BorderType border_type,
    float borderValue);
template void morph_f32<DilateVecOp, float, 3, 5>(
    const int32_t height,
    const int32_t width,
    int32_t srcStride,
    const float *srcBase,
    int32_t dstStride,
    float *dstBase,
    BorderType border_type,
    float borderValue);
template void morph_f32<DilateVecOp, float, 4, 3>(
    const int32_t height,
    const int32_t width,
    int32_t srcStride,
    const float *srcBase,
    int32_t dstStride,
    float *dstBase,
    BorderType border_type,
    float borderValue);
template void morph_f32<DilateVecOp, float, 4, 5>(
    const int32_t height,
    const int32_t width,
    int32_t srcStride,
    const float *srcBase,
    int32_t dstStride,
    float *dstBase,
    BorderType border_type,
    float borderValue);

template void morph_f32<ErodeVecOp, float, 1, 3>(
    const int32_t height,
    const int32_t width,
    int32_t srcStride,
    const float *srcBase,
    int32_t dstStride,
    float *dstBase,
    BorderType border_type,
    float borderValue);
template void morph_f32<ErodeVecOp, float, 1, 5>(
    const int32_t height,
    const int32_t width,
    int32_t srcStride,
    const float *srcBase,
    int32_t dstStride,
    float *dstBase,
    BorderType border_type,
    float borderValue);
template void morph_f32<ErodeVecOp, float, 3, 3>(
    const int32_t height,
    const int32_t width,
    int32_t srcStride,
    const float *srcBase,
    int32_t dstStride,
    float *dstBase,
    BorderType border_type,
    float borderValue);
template void morph_f32<ErodeVecOp, float, 3, 5>(
    const int32_t height,
    const int32_t width,
    int32_t srcStride,
    const float *srcBase,
    int32_t dstStride,
    float *dstBase,
    BorderType border_type,
    float borderValue);
template void morph_f32<ErodeVecOp, float, 4, 3>(
    const int32_t height,
    const int32_t width,
    int32_t srcStride,
    const float *srcBase,
    int32_t dstStride,
    float *dstBase,
    BorderType border_type,
    float borderValue);
template void morph_f32<ErodeVecOp, float, 4, 5>(
    const int32_t height,
    const int32_t width,
    int32_t srcStride,
    const float *srcBase,
    int32_t dstStride,
    float *dstBase,
    BorderType border_type,
    float borderValue);


template void morph_f32<DilateVecOp, uchar, 1, 3>(
    const int32_t height,
    const int32_t width,
    int32_t srcStride,
    const uchar *srcBase,
    int32_t dstStride,
    uchar *dstBase,
    BorderType border_type,
    uchar borderValue);
template void morph_f32<DilateVecOp, uchar, 3, 3>(
    const int32_t height,
    const int32_t width,
    int32_t srcStride,
    const uchar *srcBase,
    int32_t dstStride,
    uchar *dstBase,
    BorderType border_type,
    uchar borderValue);
template void morph_f32<DilateVecOp, uchar, 4, 3>(
    const int32_t height,
    const int32_t width,
    int32_t srcStride,
    const uchar *srcBase,
    int32_t dstStride,
    uchar *dstBase,
    BorderType border_type,
    uchar borderValue);


template void morph_f32<DilateVecOp, uchar, 1, 5>(
    const int32_t height,
    const int32_t width,
    int32_t srcStride,
    const uchar *srcBase,
    int32_t dstStride,
    uchar *dstBase,
    BorderType border_type,
    uchar borderValue);
template void morph_f32<DilateVecOp, uchar, 3, 5>(
    const int32_t height,
    const int32_t width,
    int32_t srcStride,
    const uchar *srcBase,
    int32_t dstStride,
    uchar *dstBase,
    BorderType border_type,
    uchar borderValue);
template void morph_f32<DilateVecOp, uchar, 4, 5>(
    const int32_t height,
    const int32_t width,
    int32_t srcStride,
    const uchar *srcBase,
    int32_t dstStride,
    uchar *dstBase,
    BorderType border_type,
    uchar borderValue);



}
}
} // namespace ppl::cv::aarch64

